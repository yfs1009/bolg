export const redirects = JSON.parse("{}")

export const routes = Object.fromEntries([
  ["/intro.html", { loader: () => import(/* webpackChunkName: "intro.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/intro.html.js"), meta: {"v":"/assets/images/cover3.jpg","e":"\n<p>尤福生</p>\n<!-- ,前端工作经验2-3年，熟悉uniapp,vue2,vue3,html+css+js+jq,axios,小程序开发,了解andriod如何内嵌html进行交互（例如自定义闹钟,日历提醒） -->\n","r":{"minutes":0.19,"words":58},"t":"介绍页","i":"circle-info","y":"a"} }],
  ["/", { loader: () => import(/* webpackChunkName: "index.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/index.html.js"), meta: {"t":"博客","i":"home"} }],
  ["/posts/axios.html", { loader: () => import(/* webpackChunkName: "posts_axios.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/posts/axios.html.js"), meta: {"d":1732579200000,"l":"2024年11月26日","c":["vue2"],"e":"\n<h2>axios的封装</h2>\n<div>在Vue应用程序中，Axios是一个流行的库，用于执行HTTP请求。它基于Promise，可以在浏览器和Node.js中使用。Vue开发者通常会选择Axios来处理API请求，因为它易于使用且功能强大。<br><br>代码示例：</div>\n<pre>import axios from 'axios'\nimport { Message } from 'element-ui'\nimport {Loading  } from 'element-ui'\n \naxios.defaults.withCredentials = true;\nlet loading;\nlet loadingNum=0;\n\nfunction startLoading() {    \n    if(loadingNum==0){\n        loading = Loading.service({\n          lock: true,\n          text: '加载中...',\n          background:'rgba(255,255,255,0.5)',\n        })\n    }\n    //请求数量加1\n    loadingNum++;\n}\nfunction endLoading() {\n    //请求数量减1\n    loadingNum--\n    if(loadingNum&lt;=0){\n        loading.close()\n    }\n}\n\n// 域名地址\naxios.defaults.baseURL = 'http://192.168.9.26:8080';\n \n \n//  REQUEST 请求异常拦截\naxios.interceptors.request.use(config =&gt; {\n    startLoading();\n    const token = localStorage.getItem('token');\n    // 将Token添加到请求头里面\n    token &amp;&amp; (config.headers['X-Access-Token'] = token);\n    return config;\n}, err =&gt; {\n    // 错误处理\n    Message.error({ message: '请求超时!' });\n    return Promise.resolve(err);\n});\n \n//  RESPONSE 响应异常拦截\naxios.interceptors.response.use(result =&gt; {\n/*     if(result.data.message==\"Token失效,请重新登录\"||res.data.message === 'token非法无效'){\n\n    } */\n        endLoading();\n        return result\n\n\n/*     if (result.data.code &amp;&amp; result.data.code != 200) {\n        Message.error({ message: result.data.msg });\n        // 非法进入时直接跳到登录页\n        window.location.href = '/';\n        return;\n    };\n    return result; */\n}, err =&gt; {\n \n    if (err &amp;&amp; err.response) {\n        switch (err.response.status) {\n            case 401:\n                err.message = '请求方式错误!';\n                break;\n            case 402:\n                err.message = '请求参数错误!';\n                break;\n            default:\n                err.message = `登录凭证过期,请重新登录!`;\n        }\n    } else {\n        err.message = '连接服务器失败!'\n    }\n \n    Message.error({ message: err.message })\n    return Promise.resolve(err);\n})\n \n// 接口域名\nexport const url = axios.defaults.baseURL;\n \n// POST 方法封装 (处理参数与文件上传)\nexport const postRequest = (url, params) =&gt; {\n    return axios({\n        method: 'post',\n        url: url,\n        data: params\n    });\n}\n \n \n//  GET 方法封装\nexport const getRequest = (url, params) =&gt; {\n    return axios({\n        method: 'get',\n        url: url,\n        params: params\n    });\n}\n \n//  PUT 方法封装\nexport const putRequest = (url, params) =&gt; {\n    return axios({\n        method: 'put',\n        url: url,\n        data: params\n    });\n}\n \n//  DELETE 方法封装\nexport const deleteRequest = (url, params) =&gt; {\n    return axios({\n        method: 'delete',\n        url: url,\n        data: params\n    });\n}\n</pre>","r":{"minutes":1.4,"words":421},"t":"axios","i":"pen-to-square","y":"a"} }],
  ["/posts/canvas.html", { loader: () => import(/* webpackChunkName: "posts_canvas.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/posts/canvas.html.js"), meta: {"d":1732579200000,"l":"2024年11月26日","c":["canvas"],"e":"\n<h2>canvas 水印</h2>\n<div>Canvas 对象是 HTML5 中新增的。HTML5 canvas 标签用于绘制图像（通过脚本，通常是 JavaScript）。<br><br>代码示例：</div>\n<pre>    var canvas=document.getElementById('canvas');\n\t\tvar ctx=canvas.getContext('2d');\n\t\tvar img=new Image();\n\t\timg.src='./img/1.jpg';\n\t\timg.onload=function(){\n\t\t    ctx.drawImage(img,0,0);\n\t\t    var logo=new Image();\n\t\t    logo.src='./img/z.png';\n\t\t    logo.onload=function(){\n\t\t        var dimensions={\n\t\t            x: canvas.width/2-logo.width/2,\n\t\t            y: canvas.height/2-logo.height/2,\n\t\t            width: logo.width,\n\t\t            height: logo.height\n\t\t        };\n\t\t        ctx.drawImage(logo,dimensions.x, dimensions.y, dimensions.width, dimensions.height);\n\t\t        var imageURL=canvas.toDataURL('image/png');\n\t\t    }\n\t\t}\n</pre>","r":{"minutes":0.34,"words":101},"t":"canvas","i":"pen-to-square","y":"a"} }],
  ["/posts/fetch.html", { loader: () => import(/* webpackChunkName: "posts_fetch.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/posts/fetch.html.js"), meta: {"d":1732579200000,"l":"2024年11月26日","c":["fetch"],"e":"\n<h2>fetch 请求流</h2>\n<div>fetch()是一个全局方法，提供一种简单，合理的方式跨网络获取资源。它的请求是基于Promise。<br><br>代码示例：</div>\n<pre>    try {\n        response = await fetch(app.chatbase+\"api/chat_stream\", {\n\t\t// response = await fetch(\"http://no3.ybinu.cn:33892/api/chat_stream\", {\n            signal: signal,\n            method: 'post',\n            body: JSON.stringify({\n                prompt: app.会话模式.问题 + app.问题,\n                temperature: app.temperature,\n                top_p: app.top_p,\n                max_length: app.max_length,\n                history: QA_history,\n                pdf: app.chatPDF,\n\t\t\t\tplayVideo:playVideo\n            }),\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        })\n        app.问题 = ''\t\t\n        const reader = response.body.getReader();\n        let buffer = ''\n        while (true) {\n            const { value, done } = await reader.read();\n\t\t\tconsole.log(value,\"value\")\n\t\t\tconsole.log(done,\"done\")\n            已排队到 = true\n            let res = new TextDecoder(\"utf-8\").decode(value)\n\t\t\t// console.log(res,\"res\")\n            buffer += res\n\t\t\t// console.log(buffer,\"buffer\")\n            while (buffer.indexOf(\"///\") &gt; -1) {\n                if (buffer == '/././') {//应对网络问题\n                    done = true\n                    break\n                }\n                buffer = buffer.split(\"///\")\n                当前会话.content = buffer[buffer.length - 2]\n\t\t\t\t// console.log(当前会话.content,\"当前会话.content\")\n                buffer = buffer[buffer.length - 1]\n\t\t\t\t// console.log(buffer,21212)\n            }\n\t\t\t// console.log(done,99999999999999)\n            if (done){\n            \t break\n            }\n        }\n    }catch (e) {\n\t\tconsole.log(e,\"错误信息\");\n    }\n</pre>","r":{"minutes":0.71,"words":213},"t":"fetch","i":"pen-to-square","y":"a"} }],
  ["/posts/video.html", { loader: () => import(/* webpackChunkName: "posts_video.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/posts/video.html.js"), meta: {"d":1732579200000,"l":"2024年11月26日","c":["video"],"e":"\n<h2>video 视频悬停进度条显示预览图</h2>\n<div><br>解决获取视频截图报跨域(在video组件上加上crossOrigin=\"Anonymous\" 允许跨域)代码示例：</div>\n<p><a href=\"https://www.lmlphp.com/user/151017/article/item/6447252/\">video悬停进度预览图</a></p>\n","r":{"minutes":0.23,"words":68},"t":"video","i":"pen-to-square","y":"a"} }],
  ["/posts/webaudio.html", { loader: () => import(/* webpackChunkName: "posts_webaudio.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/posts/webaudio.html.js"), meta: {"d":1732579200000,"l":"2024年11月26日","c":["WebAudio"],"e":"\n<h2>WebAudio 实时检测声音</h2>\n<div><br><br>代码示例：</div>\n<pre>    detection() {\n\t\t\tvar that = this\n\t\t\t// 获取音频流\n\t\t\tnavigator.mediaDevices.getUserMedia({\n\t\t\t\t\taudio: true\n\t\t\t\t})\n\t\t\t\t.then(stream =&gt; {\n\t\t\t\t\tconst audioContext = new AudioContext();\n\t\t\t\t\tconst audioSource = audioContext.createMediaStreamSource(stream);\n\t\t\t\t\tconst mediaRecorder = new MediaRecorder(stream);\n<pre><code>\t\t\t\tmediaRecorder.mimeType = \"audio/wav\";\n\t\t\t\t// 创建一个BiquadFilterNode，用于降低噪声\n\t\t\t\tlet lowPassFilter = audioContext.createBiquadFilter();\n\t\t\t\tlowPassFilter.type = 'lowpass'; // 设置为低通滤波器\n\t\t\t\tlowPassFilter.frequency.value = 3000; // 设置滤波器滤除的频率范围\n\t\t\t\t// 定义一个数组来存储音频数据块\n\t\t\t\tvar audioChunks = [];\n\t\t\t\t// 创建分析器节点\n\t\t\t\tconst analyzerNode = audioContext.createAnalyser();\n\t\t\t\tanalyzerNode.fftSize = 2048;\n\t\t\t\t// 建立连接\n\t\t\t\taudioSource.connect(lowPassFilter);\n\t\t\t\t//连接扬声器（需要关闭不然会有回放）\n\t\t\t\t// lowPassFilter.connect(audioContext.destination);\n\t\t\t\t// 连接音频源到分析器节点\n\t\t\t\taudioSource.connect(analyzerNode);\n\t\t\t\t\n\n\n\t\t\t\tmediaRecorder.addEventListener('dataavailable', function(event) {\n\t\t\t\t\t// 这里是录音的数据Blob对象，可以发送给后端\n\t\t\t\t\taudioChunks.push(event.data);\n\t\t\t\t\t// 使用WebSocket、Fetch API或其他方式发送audioBlob给后端\n\t\t\t\t});\n\t\t\t\t// 停止录音后，合并所有Blob对象\n\t\t\t\tmediaRecorder.addEventListener('stop', function() {\n\t\t\t\t\tif (that.demostate == true) return\n\t\t\t\t\tvar combinedBlob = new Blob(audioChunks, {\n\t\t\t\t\t\ttype: 'audio/wav'\n\t\t\t\t\t});\n\t\t\t\t\taudioChunks = []\n\n\t\t\t\t\tconsole.log(combinedBlob, \"combinedBlob\")\n\t\t\t\t\tvar formData = new FormData()\n\t\t\t\t\t// 此处获取到blob对象后需要设置fileName满足当前项目上传需求，其它项目可直接传把blob作为file塞入formData\n\t\t\t\t\tvar fileOfBlob = new File([combinedBlob], new Date().getTime() + '.wav')\n\n\t\t\t\t\tconsole.log(fileOfBlob, \"fileOfBlob\")\n\t\t\t\t\tformData.append('file', fileOfBlob)\n\t\t\t\t\tconsole.log(formData, \"formData\")\n\t\t\t\t\tdocument.getElementById(\"loadtxt\").innerText = \"思考中...\"\n\t\t\t\t\t// 直接用ajax上传\n\t\t\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\t\t\txhr.open(\"POST\", app.voicebase +\n\t\t\t\t\t\"getWordfromWav\"); /\n\t\t\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t\t\tconsole.log(xhr, \"响应数据\")\n\t\t\t\t\t\tif (xhr.readyState == 4) {\n\t\t\t\t\t\t\tlet responseText = JSON.parse(xhr.responseText);\n\t\t\t\t\t\t\tdocument.getElementById(\"loadtxt\").innerText = \"\"\n\n\t\t\t\t\t\t\tif (responseText.voice_text.result[0] != \"\") {\n\t\t\t\t\t\t\t\tdocument.getElementById(\"loadtxt\").innerText = responseText\n\t\t\t\t\t\t\t\t\t.voice_text.result[0] || ''\n\t\t\t\t\t\t\t\tthat.问题 = responseText.voice_text.result[0]\n\t\t\t\t\t\t\t\t提交()\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\txhr.send(formData);\n\t\t\t\t\txhr.onerror = function() {\n\t\t\t\t\t\talert(\"上传失败\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// 定义检测函数\n\t\t\t\tfunction detectSpeech() {\n\t\t\t\t\tconst bufferLength = analyzerNode.frequencyBinCount;\n\t\t\t\t\tconst dataArray = new Uint8Array(bufferLength);\n\n\t\t\t\t\tanalyzerNode.getByteFrequencyData(dataArray);\n\n\t\t\t\t\t// 检查音频数据中是否有能量值大于阈值的部分\n\t\t\t\t\tconst threshold = 120; // 调整阈值以适应实际情况\n\t\t\t\t\tvar state = false\n\t\t\t\t\tfor (let i = 0; i &lt; bufferLength; i++) {\n\t\t\t\t\t\tif (dataArray[i] &gt; threshold) {\n\t\t\t\t\t\t\tconsole.log(\"有人在说话！\");\n\t\t\t\t\t\t\tstate = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (state) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\t// 设置一个定时器，用于检测是否有人说话\n\t\t\t\tsetInterval(() =&gt; {\n\t\t\t\t\t// 在这里可以添加检测声音的逻辑，例如使用Web Audio API分析音频数据\n\t\t\t\t\t// 如果检测到有人说话，则继续录音；否则，停止录音并发送数据给后端\n\t\t\t\t\tconst isSpeaking = detectSpeech(); // 自定义函数，返回true表示有人在说话，false表示没有人在说话\n\t\t\t\t\tif (isSpeaking) {\n\t\t\t\t\t\t// 继续录音\n\t\t\t\t\t\tif (that.demostate == true) {\n\t\t\t\t\t\t\tdocument.getElementById(\"loadtxt\").innerText = \"\"\n\t\t\t\t\t\t\tmediaRecorder.stop();\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdocument.getElementById(\"loadtxt\").innerText = \"说话中...\"\n\t\t\t\t\t\tmediaRecorder.start();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmediaRecorder.stop();\n\t\t\t\t\t}\n\t\t\t\t}, 100); // 每100毫秒检测一次\n\n\t\t\t})\n\t\t\t.catch(error =&gt; {\n\t\t\t\tconsole.error(\"获取音频流失败:\", error);\n\t\t\t});\n\t},\n</code></pre>\n</pre>","r":{"minutes":2.02,"words":605},"t":"WebAudio","i":"pen-to-square","y":"a"} }],
  ["/404.html", { loader: () => import(/* webpackChunkName: "404.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/404.html.js"), meta: {"t":""} }],
  ["/posts/", { loader: () => import(/* webpackChunkName: "posts_index.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/posts/index.html.js"), meta: {"t":"Posts"} }],
  ["/category/", { loader: () => import(/* webpackChunkName: "category_index.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/category/index.html.js"), meta: {"t":"分类","I":false} }],
  ["/category/vue2/", { loader: () => import(/* webpackChunkName: "category_vue2_index.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/category/vue2/index.html.js"), meta: {"t":"vue2 分类","I":false} }],
  ["/category/canvas/", { loader: () => import(/* webpackChunkName: "category_canvas_index.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/category/canvas/index.html.js"), meta: {"t":"canvas 分类","I":false} }],
  ["/category/fetch/", { loader: () => import(/* webpackChunkName: "category_fetch_index.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/category/fetch/index.html.js"), meta: {"t":"fetch 分类","I":false} }],
  ["/category/video/", { loader: () => import(/* webpackChunkName: "category_video_index.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/category/video/index.html.js"), meta: {"t":"video 分类","I":false} }],
  ["/category/webaudio/", { loader: () => import(/* webpackChunkName: "category_webaudio_index.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/category/webaudio/index.html.js"), meta: {"t":"WebAudio 分类","I":false} }],
  ["/tag/", { loader: () => import(/* webpackChunkName: "tag_index.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/tag/index.html.js"), meta: {"t":"标签","I":false} }],
  ["/article/", { loader: () => import(/* webpackChunkName: "article_index.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/article/index.html.js"), meta: {"t":"文章","I":false} }],
  ["/star/", { loader: () => import(/* webpackChunkName: "star_index.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/star/index.html.js"), meta: {"t":"星标","I":false} }],
  ["/timeline/", { loader: () => import(/* webpackChunkName: "timeline_index.html" */"D:/桌面数据/mybolg/blog/src/.vuepress/.temp/pages/timeline/index.html.js"), meta: {"t":"时间轴","I":false} }],
]);

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updateRoutes) {
    __VUE_HMR_RUNTIME__.updateRoutes(routes)
  }
  if (__VUE_HMR_RUNTIME__.updateRedirects) {
    __VUE_HMR_RUNTIME__.updateRedirects(redirects)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ routes, redirects }) => {
    __VUE_HMR_RUNTIME__.updateRoutes(routes)
    __VUE_HMR_RUNTIME__.updateRedirects(redirects)
  })
}
